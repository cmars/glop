use ast::*;

#[pub]
glop -> Glop
    = __ ms:matches __ { Glop{ matches: ms } }

matches -> Vec<Match>
    = m:match __ ms:matches { let mut ms = ms; ms.insert(0, m); ms }
    / m:match { vec![m] }

match -> Match
    = "when" __ "(" __ c:conditions __ ")" __ "{" __ a:actions __ "}" {
        Match{ conditions: c, actions: a }
    }
    / "when" __ "(" __ c:conditions __ ")" __ v:$("#!" (!"!#" .)+) "!#" {
		Match{ conditions: c, actions: vec![Action::Script(String::from(v))] }
    }

conditions -> Vec<Condition>
    = c:condition __ "," __ cs:conditions { let mut cs = cs; cs.insert(0, c); cs }
    / c:condition { vec![c] }

condition -> Condition
    = k:identifier __ op:cmpop __ v:value { Condition::Cmp(k, op, v) }
    / unaryfunc

identifier -> Identifier
    = part:idpart "." rest:identifier { let mut rest = rest; rest.insert(0, part); rest }
    / part:idpart { vec![part] }

idpart -> String
    = v:$([a-z][a-z0-9_^.]+) { String::from(v) }

value -> String
    = v:$([A-Za-z0-9_]+) { String::from(v) }
    / "\"" v:$([^"]+) "\"" { String::from(v) }

unaryfunc -> Condition
    = "message" __ k:identifier { Condition::Message(k.join(".")) }
    / "is_set" __ k:identifier { Condition::IsSet(k) }

cmpop -> CmpOpcode
    = "==" { CmpOpcode::Equal }
    / "!=" { CmpOpcode::NotEqual }

actions -> Vec<Action>
    = n:action __ ns:actions { let mut ns = ns; ns.insert(0, n); ns }
    / n:action { vec![n] }
	/ { vec![] }

action -> Action
    = "set" __ k:identifier __ v:value __ ";" { Action::SetVar(k, v) }
    / "unset" __ k:identifier __ ";" { Action::UnsetVar(k) }
    / "acknowledge" __ k:identifier __ ";" { Action::Acknowledge(k.join(".")) }
    / "exec" __ v:$([^;]+) ";" { Action::Exec(String::from(v)) }
    / "script" __ v:$("#!" (!"!#" .)+) "!#" { Action::Script(String::from(v)) }

/* The following is borrowed from rust-peg's own grammar */

__ = (whitespace / eol / comment)*

/* Modeled after ECMA-262, 5th ed., 7.4. */
comment
  = singleLineComment
  / multiLineComment

singleLineComment
  = "//" (!eolChar .)*

multiLineComment
  = "/*" (!"*/" .)* "*/"

/* Modeled after ECMA-262, 5th ed., 7.3. */
eol
  = "\n"
  / "\r\n"
  / "\r"
  / "\u{2028}"
  / "\u{2029}"

eolChar
  = [\n\r\u{2028}\u{2029}]

/* Modeled after ECMA-262, 5th ed., 7.2. */
whitespace
  = [ \t\u{00A0}\u{FEFF}\u{1680}\u{180E}\u{2000}-\u{200A}\u{202F}\u{205F}\u{3000}] // \v\f removed

